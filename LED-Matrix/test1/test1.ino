// 
//
//http://embed.plnkr.co/3VUsekP3jC5xwSIQDVHx/preview

#define ROW_1 2
#define ROW_2 3
#define ROW_3 4
#define ROW_4 5
#define ROW_5 6
#define ROW_6 7
#define ROW_7 8
#define ROW_8 9

#define COL_1 10
#define COL_2 11
#define COL_3 12
#define COL_4 13
#define COL_5 A0
#define COL_6 A1
#define COL_7 A2
#define COL_8 A3


const byte rows[] = {
    ROW_1, ROW_2, ROW_3, ROW_4, ROW_5, ROW_6, ROW_7, ROW_8
};

//(1 = ON, 0 = OFF)

byte heart[] = {B00000000,B01100110,B11111111,B11111111,B01111110,B00111100,B00011000,B00000000};

byte A[] = {B00011000,B00100100,B01000010,B01000010,B01111110,B01000010,B01000010,B01000010};
byte B[] = {B01111100,B01000010,B01000100,B01111000,B01000100,B01000010,B01000010,B01111110};
byte C[] = {B01111110,B01000000,B01000000,B01000000,B01000000,B01000000,B01000000,B01111110};
byte D[] = {B01111000,B01000100,B01000010,B01000010,B01000010,B01000010,B01000100,B01111000};
byte E[] = {B01111110,B01000000,B01000000,B01111000,B01000000,B01000000,B01000000,B01111110};
byte F[] = {B01111110,B01000000,B01000000,B01111100,B01000000,B01000000,B01000000,B01000000};
byte G[] = {B01111110,B01000000,B01000000,B01000000,B01001110,B01000010,B01000010,B01111110};
byte H[] = {B01000010,B01000010,B01000010,B01111110,B01000010,B01000010,B01000010,B01000010};
byte I[] = {B00001000,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000};
byte J[] = {B01111110,B00001000,B00001000,B00001000,B00001000,B00001000,B01001000,B00110000};
byte K[] = {B01000100,B01001000,B01010000,B01100000,B01010000,B01001000,B01000100,B01000010};
byte L[] = {B01000000,B01000000,B01000000,B01000000,B01000000,B01000000,B01000000,B01111110};
byte M[] = {B01000001,B01100011,B01010101,B01001001,B01000001,B01000001,B01000001,B01000001};
byte N[] = {B01000001,B01100001,B01010001,B01001001,B01000101,B01000011,B01000001,B01000001};
byte O[] = {B01111110,B01000010,B01000010,B01000010,B01000010,B01000010,B01000010,B01111110};
byte P[] = {B01111110,B01000010,B01000010,B01111110,B01000000,B01000000,B01000000,B01000000};
byte Q[] = {B01111110,B01000010,B01000010,B01000010,B01000010,B01001010,B01000110,B01111110};
byte R[] = {B01111110,B01000010,B01000010,B01111110,B01010000,B01001000,B01000100,B01000010};
byte S[] = {B01111110,B01000000,B01000000,B01111110,B00000010,B00000010,B00000010,B01111110};
byte T[] = {B01111111,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000};
byte U[] = {B01000010,B01000010,B01000010,B01000010,B01000010,B01000010,B01000010,B01111110};
byte V[] = {B01000001,B01000001,B01000001,B01000001,B01000001,B00100010,B00010100,B00001000};
byte W[] = {B01000001,B01000001,B01000001,B01000001,B01001001,B01010101,B01100011,B01000001};
byte X[] = {B00000000,B01000001,B00100010,B00010100,B00001000,B00010100,B00100010,B01000001};
byte Y[] = {B01000001,B01000001,B00100010,B00010100,B00001000,B00001000,B00001000,B00001000};
byte Z[] = {B01111111,B00000010,B00000100,B00001000,B00010000,B00100000,B01000000,B01111111};

byte LA[] = {B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000};
byte LB[] = {B00000000,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000};
byte LC[] = {B00000000,B00000000,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000};
byte LD[] = {B00000000,B00000000,B00000000,B11111111,B00000000,B00000000,B00000000,B00000000};
byte LE[] = {B00000000,B00000000,B00000000,B00000000,B11111111,B00000000,B00000000,B00000000};
byte LF[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B00000000,B00000000};
byte LG[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B00000000};
byte LH[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111};



byte happy[] = {B00000000,B01100110,B01100110,B00000000,B11111111,B11111111,B01111110,B00111100};

byte smile[] = {B00111100,B01000010,B10100101,B10000001,B10100101,B10011001,B01000010,B00111100};
byte normal[] = {B00111100,B01000010,B10100101,B10000001,B10000001,B10111101,B01000010,B00111100};
byte sad[] = {B00111100,B01000010,B10100101,B10000001,B10011001,B10100101,B01000010,B00111100};

byte AA[] = {B10101010,B01010101,B10101010,B01010101,B10101010,B01010101,B10101010,B01010101};
byte BB[] = {B01010101,B10101010,B01010101,B10101010,B01010101,B10101010,B01010101,B10101010};



float timeCount = 0;




void setup() {
    // Open serial port
    Serial.begin(9600);
    
    // Set all used pins to OUTPUT
    // This is very important! If the pins are set to input
    // the display will be very dim.
    for (byte i = 2; i <= 13; i++)
    pinMode(i, OUTPUT);
    pinMode(A0, OUTPUT);
    pinMode(A1, OUTPUT);
    pinMode(A2, OUTPUT);
    pinMode(A3, OUTPUT);   
}




void loop() {
delay(5);

drawScreen(AA);
/*timeCount += 1;
if(timeCount <  50) {
drawScreen(A);
} else if (timeCount < 60) {
//nothibg
} else if (timeCount < 110) {
drawScreen(L);
} else if (timeCount < 120) {
//N
} else if(timeCount < 170) {
drawScreen(I);
} else if (timeCount < 180) {
//N
} else if (timeCount < 230) {
drawScreen(S);
} else if (timeCount < 240) {
//
} else if (timeCount < 290) {
drawScreen(S);
} else if (timeCount < 300) {
//nothing
} else if (timeCount < 350) {
drawScreen(O);
} else if (timeCount < 360) {
//nothing
} else if (timeCount < 410) {
drawScreen(N);
} else if (timeCount < 450) {
//nothing
} else if (timeCount < 500) {
drawScreen(happy);
} else if (timeCount < 550) {
//nothing
}
else {
// back to the start
timeCount = 0;
}*/
}



void  drawScreen(byte buffer2[]){
     
    
   // Turn on each row in series
    for (byte i = 0; i < 8; i++) {
        setColumns(buffer2[i]); // Set columns for this specific row
        
        digitalWrite(rows[i], HIGH);
        delay(2); // Set this to 50 or 100 if you want to see the multiplexing effect!
        digitalWrite(rows[i], LOW);
       
    }
    
}


void setColumns(byte b) {
    digitalWrite(COL_1, (~b >> 0) & 0x01); // Get the 1st bit: 10000000
    digitalWrite(COL_2, (~b >> 1) & 0x01); // Get the 2nd bit: 01000000
    digitalWrite(COL_3, (~b >> 2) & 0x01); // Get the 3rd bit: 00100000
    digitalWrite(COL_4, (~b >> 3) & 0x01); // Get the 4th bit: 00010000
    digitalWrite(COL_5, (~b >> 4) & 0x01); // Get the 5th bit: 00001000
    digitalWrite(COL_6, (~b >> 5) & 0x01); // Get the 6th bit: 00000100
    digitalWrite(COL_7, (~b >> 6) & 0x01); // Get the 7th bit: 00000010
    digitalWrite(COL_8, (~b >> 7) & 0x01); // Get the 8th bit: 00000001
    
    // If the polarity of your matrix is the opposite of mine
    // remove all the '~' above.
}

void Write(byte teste[], int i){
timeCount += 1;
if(timeCount <  i) {
drawScreen(teste);
}else
{
  timeCount = 0;
  }
}
